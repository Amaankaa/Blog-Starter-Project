package usecases_test

import (
	"context"
	"errors"
	"testing"
	"time"

	userpkg "github.com/Amaankaa/Blog-Starter-Project/Domain/user"
	"github.com/Amaankaa/Blog-Starter-Project/Usecases"
	"github.com/Amaankaa/Blog-Starter-Project/mocks"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type UserUsecaseTestSuite struct {
	suite.Suite
	ctx context.Context
	usecase *usecases.UserUsecase
	mockUserRepo *mocks.IUserRepository
	mockPasswordSvc *mocks.IPasswordService
	mockTokenRepo *mocks.ITokenRepository
	mockJWTService *mocks.IJWTService
	mockEmailVerifier *mocks.IEmailVerifier
	mockEmailSender *mocks.IEmailSender
	mockPasswordResetRepo *mocks.IPasswordResetRepository
}

func (s *UserUsecaseTestSuite) SetupTest() {
	s.ctx = context.Background()
	s.mockUserRepo = new(mocks.IUserRepository)
	s.mockPasswordSvc = new(mocks.IPasswordService)
	s.mockTokenRepo = new(mocks.ITokenRepository)
	s.mockJWTService = new(mocks.IJWTService)
	s.mockEmailVerifier = new(mocks.IEmailVerifier)
	s.mockEmailSender = new(mocks.IEmailSender)
	s.mockPasswordResetRepo = new(mocks.IPasswordResetRepository)
	s.usecase = usecases.NewUserUsecase(
		s.mockUserRepo,
		s.mockPasswordSvc,
		s.mockTokenRepo,
		s.mockJWTService,
		s.mockEmailVerifier,
		s.mockEmailSender,
		s.mockPasswordResetRepo,
	)
}

func TestUserUsecaseTestSuite(t *testing.T) {
	suite.Run(t, new(UserUsecaseTestSuite))
}


func (s *UserUsecaseTestSuite) RegisterFirstUserAsAdmin() {
    user := userpkg.User{
        Username: "adminuser",
        Email:    "admin@example.com",
        Password: "StrongP@ss1",
        Fullname: "Admin User",
    }

    s.mockEmailVerifier.On("IsRealEmail", user.Email).Return(true, nil)
    s.mockUserRepo.On("ExistsByUsername", mock.Anything, user.Username).Return(false, nil)
    s.mockUserRepo.On("ExistsByEmail", mock.Anything, user.Email).Return(false, nil)
    s.mockUserRepo.On("CountUsers", mock.Anything).Return(0, nil)
    s.mockPasswordSvc.On("HashPassword", user.Password).Return("hashedpassword", nil)
    s.mockUserRepo.On("CreateUser", mock.Anything, mock.Anything).Return(user, nil)

    result, err := s.usecase.RegisterUser(s.ctx, user)
    assert.NoError(s.T(), err)
    assert.Equal(s.T(), "admin", result.Role)
}

func (s *UserUsecaseTestSuite) RegisterSecondUserAsNormal() {
    user := userpkg.User{
        Username: "normaluser",
        Email:    "user@example.com",
        Password: "StrongP@ss1",
        Fullname: "Normal User",
    }

    s.mockEmailVerifier.On("IsRealEmail", user.Email).Return(true, nil)
    s.mockUserRepo.On("ExistsByUsername", mock.Anything, user.Username).Return(false, nil)
    s.mockUserRepo.On("ExistsByEmail", mock.Anything, user.Email).Return(false, nil)
    s.mockUserRepo.On("CountUsers", mock.Anything).Return(1, nil)
    s.mockPasswordSvc.On("HashPassword", user.Password).Return("hashedpassword", nil)
    s.mockUserRepo.On("CreateUser", mock.Anything, mock.Anything).Return(user, nil)

    result, err := s.usecase.RegisterUser(s.ctx, user)
    assert.NoError(s.T(), err)
    assert.Equal(s.T(), "user", result.Role)
}

func (s *UserUsecaseTestSuite) TestRejectsInvalidEmailFormat() {
    user := userpkg.User{
        Username: "bademail",
        Email:    "notanemail",
        Password: "StrongP@ss1",
        Fullname: "Bad Email",
    }

    _, err := s.usecase.RegisterUser(s.ctx, user)
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "invalid email format")
}

func (s *UserUsecaseTestSuite) TestRejectWeakPassword() {
    user := userpkg.User{
        Username: "weakpass",
        Email:    "weak@example.com",
        Password: "123",
        Fullname: "Weak Pass",
    }

    _, err := s.usecase.RegisterUser(s.ctx, user)
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "password must be at least")
}

func (s *UserUsecaseTestSuite) TestRejectDuplicateUsername() {
    user := userpkg.User{
        Username: "dupeuser",
        Email:    "unique@example.com",
        Password: "StrongP@ss1",
        Fullname: "Dupe User",
    }

    s.mockEmailVerifier.On("IsRealEmail", user.Email).Return(true, nil)
    s.mockUserRepo.On("ExistsByUsername", mock.Anything, user.Username).Return(true, nil)

    _, err := s.usecase.RegisterUser(s.ctx, user)
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "username already taken")
}

func (s *UserUsecaseTestSuite) TestRejectDuplicateEmail() {
    user := userpkg.User{
        Username: "uniqueuser",
        Email:    "dupe@example.com",
        Password: "StrongP@ss1",
        Fullname: "Dupe Email",
    }

    s.mockEmailVerifier.On("IsRealEmail", user.Email).Return(true, nil)
    s.mockUserRepo.On("ExistsByUsername", mock.Anything, user.Username).Return(false, nil)
    s.mockUserRepo.On("ExistsByEmail", mock.Anything, user.Email).Return(true, nil)

    _, err := s.usecase.RegisterUser(s.ctx, user)
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "email already taken")
}

func (s *UserUsecaseTestSuite) TestRejectEmptyFields() {
    user := userpkg.User{}

    _, err := s.usecase.RegisterUser(s.ctx, user)
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "all fields are required")
}

func (s *UserUsecaseTestSuite) TestFailsIfEmailVerifierErrors() {
    user := userpkg.User{
        Username: "erroruser",
        Email:    "error@example.com",
        Password: "StrongP@ss1",
        Fullname: "Error User",
    }

    s.mockEmailVerifier.On("IsRealEmail", user.Email).Return(false, errors.New("verifier down"))

    _, err := s.usecase.RegisterUser(s.ctx, user)
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "failed to verify email")
}

func (s *UserUsecaseTestSuite) TestRefreshToken_Success() {
    refreshToken := "valid_refresh"
    userID := primitive.NewObjectID().Hex()
    claims := map[string]interface{}{"_id": userID}

    userObj := user.User{
        ID:       primitive.ObjectIDFromHex(userID),
        Username: "refresher",
        Role:     "user",
    }

    s.mockJWTService.On("ValidateToken", refreshToken).Return(claims, nil)
    s.mockTokenRepo.On("FindByRefreshToken", s.ctx, refreshToken).Return(user.Token{
        UserID:    userObj.ID,
        ExpiresAt: time.Now().Add(1 * time.Hour),
    }, nil)
    s.mockUserRepo.On("FindByID", s.ctx, userID).Return(userObj, nil)
    s.mockJWTService.On("GenerateToken", userID, userObj.Username, userObj.Role).
        Return(user.TokenResult{
            AccessToken:       "new_access",
            RefreshToken:      "new_refresh",
            RefreshExpiresAt:  time.Now().Add(time.Hour),
        }, nil)
    s.mockTokenRepo.On("DeleteByRefreshToken", s.ctx, refreshToken).Return(nil)
    s.mockTokenRepo.On("StoreToken", s.ctx, mock.Anything).Return(nil)

    res, err := s.usecase.RefreshToken(s.ctx, refreshToken)
    assert.NoError(s.T(), err)
    assert.Equal(s.T(), "new_access", res.AccessToken)
}

func (s *UserUsecaseTestSuite) TestRefreshToken_InvalidToken() {
    s.mockJWTService.On("ValidateToken", "bad_token").Return(nil, errors.New("invalid"))

    _, err := s.usecase.RefreshToken(s.ctx, "bad_token")
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "invalid or expired")
}

func (s *UserUsecaseTestSuite) TestRefreshToken_TokenExpired() {
    token := user.Token{
        ExpiresAt: time.Now().Add(-1 * time.Hour),
    }
    claims := map[string]interface{}{"_id": "userid"}

    s.mockJWTService.On("ValidateToken", "expired_token").Return(claims, nil)
    s.mockTokenRepo.On("FindByRefreshToken", s.ctx, "expired_token").Return(token, nil)

    _, err := s.usecase.RefreshToken(s.ctx, "expired_token")
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "expired")
}

func (s *UserUsecaseTestSuite) TestRefreshToken_UserNotFound() {
    userID := primitive.NewObjectID().Hex()
    claims := map[string]interface{}{"_id": userID}

    s.mockJWTService.On("ValidateToken", "ref_token").Return(claims, nil)
    s.mockTokenRepo.On("FindByRefreshToken", s.ctx, "ref_token").Return(user.Token{
        UserID:    primitive.ObjectIDFromHex(userID),
        ExpiresAt: time.Now().Add(1 * time.Hour),
    }, nil)
    s.mockUserRepo.On("FindByID", s.ctx, userID).Return(user.User{}, errors.New("not found"))

    _, err := s.usecase.RefreshToken(s.ctx, "ref_token")
    assert.Error(s.T(), err)
    assert.Contains(s.T(), err.Error(), "not found")
}